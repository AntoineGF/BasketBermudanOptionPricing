function S = CorrelatedBrownian(S0,r,y,sigma,corr_matrix,T,steps,nsims,antithetic)
%rng default
% Function to generate correlated sample paths for assets assuming geometric Brownian motion.
%
% Inputs: S0:             row vector of stock price of each asset
%         r:              annualized and continously compounded risk free rate
%         y:              row vector of annualized and continously compounded dividend yield of each asset
%         sigma:          row vector of volatilites of each asset
%         corr_matrix:    correlation matrix of Wiener processes
%         T:              Time to expiration
%         steps:          number of equidistant exercise opportunities
%         nsims:          number of simulation paths
%         antithetic:     Dummy =1 if with antithetic variance reduction
%
% Output: S:              3 dimensional matrix of size steps X nsims X n_assets

%% Preparation

% n_assets defines number of assets in sample
n_assets=length(S0);
    
% define mu (expected value vector) as difference between risk free rate and dividend yield
mu = r-y; 

% size of each step
dt=T/steps; 

% calculate the drift
nu = mu - sigma.*sigma/2;

% Computes the upper triangular matrix via a Cholesky Decomposition
L = chol(corr_matrix);

% Define final matrix structure
S = nan(steps+1,nsims,n_assets);

%% Generate GBM Simulation

% generate paths for each asset generated by a correlated geometric
% Brownian Motion
for i = 1:nsims
    % generate uncorrelated random sequence
    x = randn(steps,size(corr_matrix,2));   
    
    % add correlation to randomness
    ep = x*L;
    if(antithetic~=1)
    % Generate paths for each asset
    S(:,i,:) = [ones(1,n_assets); ...
        cumprod(exp(repmat(nu*dt,steps,1)+ep*diag(sigma)*sqrt(dt)))]*diag(S0);
    else 
    S(:,i,:) = [ones(1,n_assets); ...
     cumprod(exp(repmat(nu*dt,steps,1)-ep*diag(sigma)*sqrt(dt)))]*diag(S0);
    end
end
